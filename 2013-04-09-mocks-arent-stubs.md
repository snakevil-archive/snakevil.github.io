---
layout: post
title: 【译】模拟（对象）不是存根（对象）
date: 2013-04-09 11:07:34+08:00
tags: ["translation", "study-trace", "unit-test", "xunit", "tdd"]
excerpt: 『模拟对象』一词，开始越来越多地用于描述那些在测试中模仿真实对象的特殊对象。绝大多数的语言环境现在都有了能够轻易创建模拟对象的框架。但是，往往没有意识到地是，模拟对象是一种非常特殊的测试用对象，因为它使我们拥有了一种完全不同风格的测试方法。在本文中，我将解释模拟对象是如何工作，它们是如何鼓励基于行为验证的测试，以及那些关注于它们的社区是如何在使用它们来制定一种不同的测试风格。
---

## 目录 ##

* [常规测试](#regular-tests)
* [使用模拟对象进行测试](#tests-with-mock-objects)
    * [使用 EasyMock](#using-easymock)
* [模拟（对象）与存根（对象）的区别](#difference-between-mocks-and-stubs)
* [古典测试和模拟主义的测试](#classical-and-mockist-testing)
* [根据差异选择](#choosing-between-differences)
    * [驾驭 TDD](#driving-tdd)
    * [场地搭建](#fixture-setup)
    * [测试隔离](#test-isolation)
    * [结合测试来实现（功能）](#coupling-tests-to-implementations)
    * [设计风格](#design-style)
* [做古典主义者还是模拟主义者？](#so-should-i-be-classicist-or-mockist)
* [最后的想法](#final-thoughts)

## 引言 ##

我第一次了解『模拟对象』这个术语，是在几年前的 XP 社区中。从那时起，我开始越来越多地接触到模拟对象。一部分是因为许多模拟对象的优秀开发人员其实是我在 ThoughtWorks 不同时期的同事。一部分则是我在受到 XP 理念所影响的测试文化中越来越多地看到它们。

但大多数情况下，对模拟对象的解读都很苍白。特别是我能够经常看到将存根（对象）——一种测试环境中常用的辅助工具——与它们弄混的情况。我理解这种困惑，因为我也曾在一段时期内认为它们是很相似的。幸而经过与模拟（框架）开发者们的交流，我对模拟（对象）的理解变得深刻了许多。

这种区别其实涵盖了两点角度完全不同的差异。其一是测试结果如何被验证地：状态验证和行为验证之间的区别。其二是一种完全不同的、将测试和设计有机结合的哲学，在本文中，我将其命名为 TDD （测试驱动开发）的古典风格和 **模拟主义风格** 。

*译者注：『模拟主义风格』一词，其原文是「 **mockist** 」，为原文作者的自造词。因词根「 **-ist** 」代表「 **…主义的** 」和「 **…信仰的** 」之意，故如此翻译。*

（在本文的早期版本中，虽然我已经意识到了区别，但将两点差异混为一谈了。当我的理解加深后，便又更新了本文。如果你并没有阅读过之前的文章，那么你可以忽略我的成长的烦恼，因为我是忽略了之前的版本，重新写作。但如果你对之前的版本很熟悉地话，你可能会发现和注意到，我破弃了之前以 *基于状态* 和 *基于交互* 进行区分的方法，而改用 *状态验证* 和 *行为验证* 、*古典方式* 和 *模拟主义方式* 这样的方法来区别。同样地，我也调整了我的用词，以对应于 Gerard Meszaro 所著的[《xUnit Patterns》](http://xunitpatterns.com)一书。）

<!--{{ site.title }}-->

## <a name="regular-tests"></a>常规测试 ##

首先，我将通过一个简单的案例来说明这两种风格。（案例使用 Java 完成，但其中的原理使用于任何一种面向对象的语言。）我们要实现一个 *订单* 对象，并使用另一个 *仓库* 对象对其进行供给。 *订单* 非常简单，只有一个 *产品* 和相应的 *数量* 。而 *仓库* 则库存着不同的 *产品* 。当我们要求从 *仓库* 供给 *订单*  有两种可能结果。如果 *仓库* 中对应 *产品* 的库存足够，那么 *订单* 应被供给，同时 *仓库* 中的 *产品* 库存减少相应的 *数量* 。否则 *订单* 应无法被供给，而 *仓库* 则不发生任何变化。

这两种行为意味着一些很普通的 JUnit 测试。

```java
public class OrderStateTester extends TestCase {
  private static String TALISKER = "Talisker";
  private static String HIGHLAND_PARK = "Highland Park";
  private Warehouse warehouse = new WarehouseImpl();

  protected void setUp() throws Exception {
    warehouse.add(TALISKER, 50);
    warehouse.add(HIGHLAND_PARK, 25);
  }
  public void testOrderIsFilledIfEnoughInWarehouse() {
    Order order = new Order(TALISKER, 50);
    order.fill(warehouse);
    assertTrue(order.isFilled());
    assertEquals(0, warehouse.getInventory(TALISKER));
  }
  public void testOrderDoesNotRemoveIfNotEnough() {
    Order order = new Order(TALISKER, 51);
    order.fill(warehouse);
    assertFalse(order.isFilled());
    assertEquals(50, warehouse.getInventory(TALISKER));
  }
```

xUnit 测试遵循着一个典型的四相序： **搭建** 、 **演练** 、 **验证** 和 **拆卸** 。在这个案例中， **搭建** 阶段分成两部分完成，一是 `setUp()` 方法 **搭建** *仓库* ，二是测试方法 **搭建** *订单* 。对 `order.fill()` 方法的调用是 **演练** 阶段，在这里被测对象执行了我们要测试的（行为）逻辑。断言语句是 **验证** 阶段，以检查 **演练** 方法是否如期完成了它的任务。因为隐形的垃圾回收机制的原因，本例并没有明确的 **拆卸** 阶段。

在 **搭建** 过程中，我们将两种对象联系到了一起。 *订单* 是我们正在测试的类，而 `order.fill()` 方法要想正常工作又依赖于 *仓库* 的实例。在这种情况下， *订单* 就是我们测试聚焦地对象。面向测试（进行开发）的人们喜欢将其命名为『受测对象』或『受测系统』。两种叫法都很绕口，但却是被广泛认可的。按照 Meszaros （的建议），我会使用『受测系统』一词，或者其缩写 **SUT**。

故对于本例测试而言，我需要 **SUT** *订单* 和一个 **协作者** *仓库* 来达成目标。使用 *仓库* 有两个原因：一是其能够使被测行为正常地工作—— `order.fill()` 方法会调用 *仓库* 的方法；二是我需要用其来做验证—— `order.fill()` 方法的可能结果之一会改变 *仓库* 的状态。随着我们对此话题的深入，你会看到我们找出 **SUT** 和 **协作者** 之间大量的区别。（在本文的早期版本中，我使用了『主对象』来描述 **SUT** 、『辅助对象』来描述 **协作者** ）

这种测试风格使用地正是状态验证：我们通过检查 **SUT** 和 **协作者** 在 **演练** 阶段之后的状态，来判断被 **演练** 的方法是否正常工作。接下来，我们将看到，模拟对象使用了一种不同的方法来完成验证。

## <a name="tests-with-mock-objects"></a>使用模拟对象进行测试 ##

现在，我将使用模拟对象完成同样的行为（测试）。这段代码中，我是使用了 jMock 库来定义模拟（对象）。jMock 是一个 Java 语言中的模拟对象库。虽然还有其他的模拟对象库，但 jMock 是由此项技术的发起者编写，同时还保持着更新，因此应该是一个很好的开始。

```java
public class OrderInteractionTester extends MockObjectTestCase {
  private static String TALISKER = "Talisker";

  public void testFillingRemovesInventoryIfInStock() {
    //setup - data
    Order order = new Order(TALISKER, 50);
    Mock warehouseMock = new Mock(Warehouse.class);

    //setup - expectations
    warehouseMock.expects(once()).method("hasInventory")
      .with(eq(TALISKER),eq(50))
      .will(returnValue(true));
    warehouseMock.expects(once()).method("remove")
      .with(eq(TALISKER), eq(50))
      .after("hasInventory");

    //exercise
    order.fill((Warehouse) warehouseMock.proxy());

    //verify
    warehouseMock.verify();
    assertTrue(order.isFilled());
  }

  public void testFillingDoesNotRemoveIfNotEnoughInStock() {
    Order order = new Order(TALISKER, 51);
    Mock warehouse = mock(Warehouse.class);

    warehouse.expects(once()).method("hasInventory")
      .withAnyArguments()
      .will(returnValue(false));

    order.fill((Warehouse) warehouse.proxy());

    assertFalse(order.isFilled());
  }
```

在 `testFillingRemovesInventoryIfInStock` 用例中，我标记出了四相序的各个阶段。

作为第一个部分的 **搭建** 阶段就变得非常不同： *数据* 和 *期望* 两个部分。 *数据* 部分 **搭建** 了我们所感兴趣的工作对象，这和古典的 **搭建** 阶段大体上一致。但区别在于为此所创建的对象（究竟是什么）。 **SUT** 是一样的，即 *订单* 。但 **协作者** 却不再是 *仓库* ，而变为 *仓库* 的模拟对象——技术化地说法是 `Mock` 类的一个实例。

**搭建** 阶段的第二个部分则创建了对于该模拟对象的 *期望* 。要求当 **SUT** 被 **演练** 时模拟（对象）的哪些方法应该被调用。

编写完所有的 *期望* 之后，我开始 **演练** **SUT**。再然后是两个方面的 **验证** 。对 **SUT** 断言——这也和古典测试差不多。但我也同样 **验证** 了模拟对象——检查它们是否如 *期望* 一样被调用。

这里的核心差异，是在于我们究竟如何在验证 *订单* 是否在与 *仓库* 的交互过程中做了正确的事情。状态验证时，我们是针对 *仓库* 的状态进行断言。而模拟（对象）是使用行为验证地，因此我们换而检查 *订单* 是否正确地调用了 *仓库* （的方法）。这种检查工作在根据我们在 **搭建** 阶段所告诉模拟（对象）的 *期望* ，而在 **验证** 阶段通过 `warehouseMock.verify()` 方法完成。只有 *订单* 是使用断言进行检查，如果（被测试的）方法并未改变 *订单* 的状态，那么断言就会失败。

在第二个测试（用例）中，我做了一些不同的事情。首先是我创建了不同的模拟（对象），使用地是 `MockObjectTestCase.mock()` 方法，而非构造一个新的 `Mock` 类的实例。这是 jMock 库中的一个便捷方法，使我不用再在测试（用例）的结尾处显性地调用 `Mock.verify()` 方法。虽然我在第一个测试（用例）中也可以这么写，但我还是希望能够更清晰地展示使用模拟（对象）测试时 **验证** 阶段是如何工作地。

第二个测试用例中的第二个差异点，是我使用了 `withAnyArguments()` 方法放宽了对 *期望* 的约束。这是因为第一个测试（用例）已经检查过了传递给 *仓库* 的数值，所以第二个测试（用例）无须再次重复。如果未来 *订单* 的逻辑（规则）需要变更，那么就只会有一个测试（用例）失败，这也能够减少同步变更测试（用例）的工作量。实际上我也可以完全不用 `withAnyArugments()` 方法，因此这也是默认的（对实参的 *期望* ）。

### <a name="using-easymock"></a>使用 EasyMock ###

除 jMock 外还有很多其他的模拟对象库。我偶有接触地其中之一是 EasyMock，它同时拥有 Java 和 .Net 版本。EasyMock 也同样提供了行为验证，值得一提地是其实现风格与 jMock 大有不同。下面是（使用 EasyMock 的）再度测试：

```java
public class OrderEasyTester extends TestCase {
  private static String TALISKER = "Talisker";

  private MockControl warehouseControl;
  private Warehouse warehouseMock;

  public void setUp() {
    warehouseControl = MockControl.createControl(Warehouse.class);
    warehouseMock = (Warehouse) warehouseControl.getMock();
  }

  public void testFillingRemovesInventoryIfInStock() {
    //setup - data
    Order order = new Order(TALISKER, 50);

    //setup - expectations
    warehouseMock.hasInventory(TALISKER, 50);
    warehouseControl.setReturnValue(true);
    warehouseMock.remove(TALISKER, 50);
    warehouseControl.replay();

    //exercise
    order.fill(warehouseMock);

    //verify
    warehouseControl.verify();
    assertTrue(order.isFilled());
  }

  public void testFillingDoesNotRemoveIfNotEnoughInStock() {
    Order order = new Order(TALISKER, 51);

    warehouseMock.hasInventory(TALISKER, 51);
    warehouseControl.setReturnValue(false);
    warehouseControl.replay();

    order.fill((Warehouse) warehouseMock);

    assertFalse(order.isFilled());
    warehouseControl.verify();
  }
}
```
EasyMock 使用了 *录制* 和 *回放* 的类比来设置 *期望* 。对于每个你希望模拟的对象，都需要创建配套的 *控制器* 和模拟对象。模拟对象实现 **协作者** 的接口规范，*控制器* 则提供额外的功能。要添加一个 *期望* ，直接带上预期的实参去调用模拟对象的相应方法，然后调用 *控制器* 来给出你所希望的返回值。一旦你设置完 *期望* ，你可以调用 `MockControl.replay()` 进行回放——那时模拟对象已经完成了 *录制* 并以为响应 **SUT** 而准备就绪了。再然后，你就可以调用 *控制器* 的 `verify()` 了。

虽然看起来大家在最初接触 *录制* 和 *回放* 这样的类比时会倍受折磨，但还是很快就能适应和习惯。它与 jMock 相比有一个优势在于，你是真实地调用模拟对象上的方法，而不是以字符串的形式来指定 *期望* 中的方法是什么。这就意味着你完全可以使用你的 IDE 的代码补全功能，而任何对方法名的修改也能自动地反映到测试中。而缺点则在于你无法使用更为宽松的约束。

jMock 的开发者们正在使用其它的一些技术来开发一个新的版本，使我们也能使用真实的方法调用。

## <a name="difference-between-mocks-and-stubs"></a>模拟（对象）与存根（对象）的区别 ##

很多人在初次了解时都容易将模拟对象与存根对象这一常见的测试概念搞混。但很快大家就对其中的区别有了更好的理解（希望我早期版本的文章也从中提供了帮助）。然而要想完全地掌握应该如何使用模拟（对象），那么理解模拟（对象）和其它类型的测试替身就是其中的关键（替身？如果这对你而言又是一个新名词，请不要担心，阅读过接下来的章节后，你会明确它的意思地。）

当你做测试时，你一次只会聚焦于软件（系统）中的一个元素——即我们常说的『单元测试』。但问题在于要让一个单元能够工作起来，通常还需要其它单元的配合——在我们的例子中即是需要 *仓库* 的配合。

我在前文中已经展示了两种风格的测试，第一种情况下使用一个真实的 *仓库* 对象；而到了第二种情况，我们改用了一个模拟的 *仓库* 对象，既然是模拟，那么自然就并不真实了。使用模拟对象是诸多的不在测试（用例）中使用真实 *仓库* 地方法之一，此外也还有一些其它形式上地方法。

用于描述这些方法的词汇很快就开始变得混乱——各种词都被用上了：存根、模拟、伪造、傀儡…本文采用了 Gerard Meszaros 著作中的用词。这并不意味着每个人都应该这么用，而是我个人认为这些用词相对精确，这也是我自己的文章，因此我采用了这些词汇。

Meszaros 使用『测试替身』这一通用名词来概括那些在测试中替换了真实对象的伪造对象。这个名词来源于电影中替身演员的概念。（他的目标之一是避免使用任何已被广泛使用的名称。）Meszaros 同样也定义了以下四种特定的替身：

* 『傀儡』对象（在测试场景中）被传递但并不被使用。一般来说它们只是用于填充参数列表。（译者注：群众演员路人甲、乙、丙、丁们）

* 『伪造』对象能够正常工作，但一般都是并不适用于生产地简单实现——内存数据库正是一个典型例子。

* 『存根』（对象）在测试（用例）中使用预设的结果以响应调用请求，一般来说是无法返回预设值之外的内容地。『存根』（对象）也可以记录调用信息，如邮件网关的存根（对象）可能记录所“发送”地邮件，或者仅仅是“发送”地邮件的数量。

* 『模拟』（对象）则是我们探讨的话题：预编写的、带有 *期望* 的（模拟）对象制定了一个特殊规范——它们应该会接收到对哪些方法的调用请求。

*译者注：『测试替身』一词，其原文为「 **Test Double** 」，比较晦涩。需要配合『特技替身』一词，即「 **Stunt Double** 」，来辅助理解。*

在这些类型的（测试）替身中，只有模拟（对象）坚持于行为验证。其它类型的（测试）替身一般使用状态验证。模拟（对象）在 **演练** 阶段与其它类型的（测试）替身的行为表现是相同的，因为它们也需要让 **SUT** 相信自己是在和一个真实的 **协作者** 对话。其中的差异是体现在 **搭建** 和 **验证** 阶段。

要更深入地了解这些测试替身，我们需要对我们的案例做出相应的扩展。很多人仅在真实对象很难被测试时才会使用到测试替身。假定我们在供给 *订单* 失败时需要自动发送一封 *邮件* ——因为我们并不真地期望在测试过程中会给我们的客户发送这样的 *邮件* ——测试替身就变得非常有必要了。因此我们创建了我们 *邮件系统* 的测试替身作为替代品，以便我们能够更好地控制和操作。

在这里，我们就可以开始看到模拟（对象）和存根（对象）的区别了。如果我们要完成对这个发送 *邮件* 行为的测试，我们就需要编写这样的一个简单存根（对象）。

```java
public interface MailService {
  public void send (Message msg);
}
public class MailServiceStub implements MailService {
  private List<Message> messages = new ArrayList<Message>();
  public void send (Message msg) {
    messages.add(msg);
  }
  public int numberSent() {
    return messages.size();
  }
}
```

然后我们可以这样对存根（对象）进行状态验证。

```java
class OrderStateTester...
  public void testOrderSendsMailIfUnfilled() {
    Order order = new Order(TALISKER, 51);
    MailServiceStub mailer = new MailServiceStub();
    order.setMailer(mailer);
    order.fill(warehouse);
    assertEquals(1, mailer.numberSent());
  }
```

当然，这是一个非常简单的测试（用例），因为只会发出一封 *邮件* 。我们并未测试（ *邮件* ）是否发送给了正确的人，或者内容是否正确。但它已经解释了（存根对象是如何进行状态验证地）。

使用模拟（对象来实现），测试（用例）会看起来很不一样。

```java
class OrderInteractionTester...
  public void testOrderSendsMailIfUnfilled() {
    Order order = new Order(TALISKER, 51);
    Mock warehouse = mock(Warehouse.class);
    Mock mailer = mock(MailService.class);
    order.setMailer((MailService) mailer.proxy());

    mailer.expects(once()).method("send");
    warehouse.expects(once()).method("hasInventory")
      .withAnyArguments()
      .will(returnValue(false));

    order.fill((Warehouse) warehouse.proxy());
  }
}
```

在这两种情况下，我都是使用测试替身来替代真实的 *邮件服务* 。而区别在于，存根（对象）使用了状态验证，模拟（对象）使用了行为验证。

为了能在存根（对象）上使用状态验证，我需要对其添加一些额外的方法以辅助验证。因此存根（对象）不仅实现了 *邮件服务* ，还添加了额外的测试方法。

模拟对象永远都是使用行为验证，存根（对象）则两种方法皆可。Meszaros 用了『测试小偷』一词来描述使用了行为验证的存根（对象）。其中的差异在于（测试）替身究竟是如何运行、又如何验证地。这一点，我留给你们自己去探索和验证。

## <a name="classical-and-mockist-testing"></a>古典测试和模拟主义的测试 ##

现在，我们开始探索第二种划分方式：古典的 TDD 和模拟主义的 TDD。扑面而来的问题，是（我们应该）在 **_何时_**（选择）使用模拟（对象），或其它的（测试）替身？

**古典的 TDD** 风格是尽可能地使用真实对象，仅在真实对象难以用于测试时才使用（测试）替身。因此古典的 TDD 者会选用真实的 *仓库* 和 *邮件服务* 的（测试）替身。至于（测试）替身该用哪种类型，这个问题重要吗？

而一名 **模拟主义的 TDD** 的信徒，则会永远把关注地业务逻辑中涉及到的每一个对象都替换成模拟（对象）。这样 *仓库* 和 *邮件服务* 两者（都会被替换）。

尽管众多的模拟框架都是为模拟主义的测试哲学而设计，很多古典主义者还是发现它们对（自己）创建（测试）替身有所助益。

模拟主义风格的一支重要分支是 [**行为驱动开发**](http://dannorth.net/introducing-bdd/) （ BDD ）。 BDD 最初是由我的同事 Dan North 开发，聚焦于如何将 TDD 作为一门设计技术使用，以帮助人们更好地学习 TDD 。

BDD 引导（我们）以行为来命名测试（用例），以更好让 TDD 帮助（我们）思考（ **SUT** ）对象究竟应该做些什么。BDD 使用了一种模拟主义的方法，并从命名风格和分析整合两方面做了深入展开。我在本文中对其就不做更多地深入说明了，因为 BDD 与文本的唯一关系就在于其也是一种使用了模拟主义测试（风格）的 TDD 变种。你如果想了解更多，请点击前面的链接。

## <a name="choosing-between-differences"></a>根据差异选择 ##

在本文中，我已解释过了两种差异：状态验证和行为验证，古典 TDD 和模拟主义的 TDD 。那么什么是我们在它们之间做出选择前所需要铭记于心地呢？我们先从状态或行为的验证方式的选择进行切入。

首要考虑地是（测试用例的）上下文。我们需要面对地是一个简单的协作关系，如 *订单* 和 *仓库*，还是很复杂的，如 *订单* 和 *邮件服务* ？

如果这个协作关系很简单，那么选择也很简单。如果我是一个古典 TDD 者，就不用什么模拟（对象）、存根（对象）抑或是什么别的（测试）替身。我直接对真实对象做状态验证就好。而如果我是一个模拟主义 TDD 者，我就对模拟（对象）做行为验证。这确实没什么好说地。

但如果协作关系很复杂呢？如果我是一个模拟主义者，同样还是不容置疑——继续对模拟（对象）做行为验证就好了。而如果我是一个古典主义者地话，我就不能不做一个选择了，不过这并不算什么重大决定。一般来说，古典主义者会对每个（测试）用例都独立选择（不同的测试替身），以最轻松地方式来实现（测试）场景。

所以正如我们所见到地，（选择）状态验证抑或行为验证谈不上是什么重要抉择。真正地问题是在古典 TDD 和模拟主义 TDD 之间。因为它会影响（你去选择使用）哪种验证方式，进而（测试用例的）特征。而这也是我的绝大部分精力的倾注所在。

但在我真正着手之前，先提一个极端案例。某些情况下，即便（对象的）合作关系并不复杂，但同样难以做状态验证。缓存就是这种极端案例中的典型。其中的重点就在于你无法通过状态得知缓存是否命中——即时是一位最硬派的古典 TDD 者，使用行为验证同样是一个聪明的选择。我敢肯定，这两种（测试风格的）方向上都存在着其它的异常情况。

当我们深入探讨古典和模拟主义的选择时，值得思考的要素非常多，因此我（简单地）拆略（出一些）比较粗糙的分组（作为纲要）。

### <a name="driving-tdd"></a>驾驭 TDD ###

模拟对象（的概念）出在于 XP 社区，因为 XP 的主要特点之一就是依靠 TDD ——通过编写测试（用例）的形式驱动（和确保）系统设计地迭代改进。

因此不用惊讶于模拟主义者会谈及模拟主义（风格的）测试对（系统）设计的影响。而且他们还主张一种名为『需要驱动开发』的风格。基于这种风格进行开发时，编写一个针对（业务生产）系统外部环境、以接口对象做为 **SUT** 的测试（用例），是首要的第一步。然后通过思考 **协作者** 们的 *期望* ，来探索和明确 **SUT** 与其 **协作者** 们之间的交互——从而有效地设计出 **SUT** 的对外接口。

*译者注：『需要驱动开发』一词，其原文是「 **need-driven development** 」，而未使用「 **requirement** 」一词。因此意味着是按 **实际需要** 而非 **产品需求** 而来。*

当你的第一个测试（用例）成功执行之后，（用例中）模拟（对象）的 *期望* 就为接下来的开发和测试工作提供了规格（指标）。你需要将每一个 *期望* 都转化为一个针对该 **合作者** 的测试（用例），然后如此往复将每一个之前的系统边界内的 **合作者** 都转化为一个新的 **SUT** 。这种风格也被称作为『由外而内』，一种很能说明细节特征的叫法。这种方法也能应用到分层系统（的设计实现）上。首先是模拟下一层来实现 UI ，然后再编写下一层的测试（用例），逐级至完全覆盖整个系统。这是一种非常结构化地和高可控性的（实现）方法，很多人都认为该方法可以很好地引导初学者们学习 OO 和 TDD 。

古典 TDD 就无法提供这样的引导帮助了。但你还是可以使用一种类似的步进（开发）方法，只是使用地是存根方法而非模拟（对象）。要做到这一点，你需要将每次 **SUT** 对 **协作者** 的方法调用都硬编码以返回能够被测试（用例）所接受的内容。然后在测试通过后再将硬编码内容替换为合适的（业务逻辑）代码。

但古典 TDD 能做的事情并不限于此。一种常见的风格是『由中至外』。在这种风格中，你需要决定每个预期功能要能正常工作，其领域内应该涵盖哪些内容。在实现了这些领域对象之后，再将 UI 放在其上层。这种做法可能完全不再需要你去伪造什么（来让测试通过）。不少人都喜欢这种风格，因为它可以第一时间就聚焦领域模型，以免将领域逻辑泄漏到 UI 层。

我想要强调地是，模拟主义者和古典主义者其实做地是一件事情。有一种学派认为应用程序应该逐层开发，而不是在一层完成之后才开始另一层。但古典主义者和模拟主义者们往往都有一个敏捷（开发的学习）背景，并因而更倾向于细粒度的迭代。因此他们是按功能开发而非按层开发。

### <a name="fixture-setup"></a> 场地搭建 ###

*译者注：『场地』一词，其原文是「 **fixture** 」，其意义为「 **固定装置** 」和「 **体育活动** 」。中文版的《 xUnit 模式》将其翻译为技术译文中较多使用地『 **夹具** 』。因为比较晦涩难懂，因此在本文中意译为了『 **场地** 』。*

在古典 TDD 中，你在创建 **SUT** 之外还必须创建测试（用例）中所有 **SUT** 所需的 **协作者** 。虽然案例中仅仅只包含两个对象，但真实的测试（用例）往往涉及大量的 **协作者** 对象。通常情况下，这些对象需要在每次执行测试（用例）时创建然后再销毁。

而模拟主义的测试（用例），只需要创建 **SUT** 并模拟其直接 **协作者** 即可。这种做法可以在构建复杂的场地时，减少一些不必要的工作 （至少在理论上如此。我也遇到过相当复杂的模拟（对象）构建阶段，但那可能是由于工具使用不当所致。）

在实践中，古典测试者们倾向于尽可能地服用那些复杂的场地。最简单的做法就是将这些场地搭建代码放进 xUnit 的 `setUp()` 方法。如果某些复杂场地需要被应用到多个测试类中，那么建议你为这些复杂场地创建相应的生成类。我一般通常会称呼这些类叫『对象之母』，这种叫法是基于 ThoughtWorks 的一个早期 XP 项目中的命名规约而来。在较大的古典测试中使用这些『对象之母』是非常有必要地，但这也意味着我们需要维护更多的代码，并且改变这些代码会对（已有的）测试（用例）有着明显的涟漪效应。另外，这也会让场地的构建过程变得更慢——虽然我从未听说过即便处理得当，这仍然会成为一个严重的问题。绝大多数的场地对象创建起来都费不了多大功夫，而比较麻烦的情况则一般都使用了（测试）替身。

因此，我曾听到过两种风格（的倾向者）相互指责对方（风格）太费工了。模拟主义者说需要花大力气才能创建好场地，而古典主义者们则说那好歹还是在代码复用，反而模拟（对象）需要针对每个测试（用例）都创建模拟（对象）。

### <a name="test-isolation"></a>测试隔离 ###

如果基于模拟主义的测试的系统出现了一个 BUG ，那么一般只有针对包含了这个 BUG 的 **SUT** 的测试（用例）会失败。而如果是基于古典测试，除此之外，只要包含了这个 BUG 的对象做为 **协作者** 出现，相关的 **SUT** 的测试（用例）全部都会失败。因此，一个高使用度的对象中的错误会导致全系统中大量的测试（用例）都失败。

模拟主义测试者们认为这是一个大问题，因为要找到错误的根源然后修复它，需要大量的调试。而古典主义者们并不认为这是问题的根源。一般而言，通过查看未通过的测试（用例）可以相对更容易地找到罪魁祸首，然后工程师们可以告诉大家其它故障都是受到此根源的干扰。此外，如果你定期测试（你也应该如此），那么你可以知道问题来源其实是在你的最后一次编辑处，所以定位故障并不困难。

这里要强调地一个因素是测试（用例）的粒度。由于古典测试（用例）会 **演练** 多个真实对象，你经常会发现其中之一的测试（用例）是针对这群对象的主要测试（用例）。如果这群对象包含非常多的个体，那么要找出一个 BUG 的真实根源会困难得多。（其对应的）测试（用例的粒度）就过粗了。

这种问题在模拟主义的测试中鲜会出现，因为已经约定了对于非 **SUT** 的所有 **协作者** 全部都该被模拟掉，因此各个 **协作者** 应该保持何等粒度的测试（用例）是一目了然地。也就是说，使用了过粗粒度的测试（用例），并非古典测试做为一种测试技术本身的局限，而在于是否合理地使用了这种技术。将每个类分开测试，是一种能够较好地保持测试粒度的经验办法。即使这种（对象）集群某些情况下是合理的，我们还是应该尽量将其限制在有限的对象个数内——再多再多也别超过半打吧。此外，如果你发现因为测试粒度过粗而导致调试困难，你应该以测试驱动的方式来调整，创建更细粒度的测试（用例）。

古典的 xUnit 测试本质上并不仅限于单元测试，同样也包括了迷你集成测试。因此，很多人都喜欢使用从属测试（用例）来检查主测试（用例）所无法覆盖到的错误可能，特别是存在著类之间大量交互的地方。而模拟主义的测试就做不到这一点。另外，模拟主义的测试还会有因不正确的 *期望* 的风险，这可能会导致虽然测试（用例）都可以通过，但问题只是被掩盖了。

在这点上我要强调无论你是使用哪种测试风格，你都必须使用粗粒度的测试（用例）来整体覆盖全系统（，以做为验收型测试）。我经常会碰到因为使用这种验收型测试太迟而事后追悔的项目。

### <a name="coupling-tests-to-implementations"></a> 结合测试来实现（功能） ###

当你编写一个模拟主义的测试（用例）时，你是在测试 **SUT** 的对外调用来确保其是正确地在与其 **协作者** 通讯。而一个古典的测试（用例）则只关心最终的状态——而非这个状态就是如何得到。因此模拟主义的测试（用例）能够更好地保障方法的具体实现。改变对 协作者 的调用（方法）的性质，通常会导致相应的模拟主义测试（用例）无法被通过。

这种结合需要注意几点。其中最关键的一点是 TDD 的效果。使用模拟主义的测试（风格），你在编写测试（用例）时同样会思考相应的行为该如何实现——模拟主义的测试者们确实也将其视为优势之一。但古典主义者们认为在编写测试时只应该思考外部接口究竟会做些什么，而如何实现，那是在测试编写完成之后才需要思考的事情。

结合（测试）来实现还会干扰到重构工作，因为改变实现通常会破坏测试。而古典式测试就相对会较少地碰到这样的问题。

另外，这种方式也受到模拟工具制约。模拟工具通常会给出具体的方法调用和具体的实参的 *期望* ，而无法确保这些 *期望* 是否都与测试目标相关。jMock 工具的目标之一，就是能够更灵活地判断 *期望* 是否为必需，从而放松对非必要 *期望* 的约束，进而使重构工作更精细。而所付出地代价，正是使用字符串来指明 *期望* 中的方法。

### <a name="design-style"></a> 设计风格 ###

这些测试风格最吸引我的方面之一就在于它们是如何在影响设计中的决策地。在我经过与两种风格的测试者沟通之后，我开始了解不同（测试）风格所倾向地设计（方式）之间的一些差异，但我想我的认知依旧停留在表面。

我已经提到了在处理（逻辑）层上的一点区别。模拟主义式测试支持一种『由内而外』的方法，而倾向于古典式测试的开发者们则偏爱从领域模型『由（中）至外』的风格。

我注意到，对于一个收集（器）对象，模拟主义的测试者们会倾向于关注方法是会如何做而非会返回什么值。假定该方法会从一组对象中收集信息然后创建一个字符串类型的报告。常见的做法是调用每个对象的报告方法并使用一个临时的变量来收集返回的字符串。而一位模拟主义的测试者会更喜欢将一个字符串缓冲传入不同的对象，再让这些对象将不同的（报告）字符串追加到这个缓冲内——这是将这个字符串缓冲作为收集参数在使用。

模拟主义测试者们更多谈论地是如何避免『列车残骸』的问题——即 `getThis().getThat().getTheOther()` 这种风格的方法链。避免使用方法链也遵循了迪米特法则。既然方法链存在问题，那么与之相对的存在大量转发方法的中间人对象就也存在着问题。（我一直觉得将迪米特法则叫做『迪米特的建议』会让我更自在一些。）

最难让人们理解 OO 设计的一点，是『说而不问』的原则，即鼓励你去使用对象直接完成工作，而非将数据从对象中抓出来然后再自己处理。模拟主义者们认为使用模拟主义式测试有助于保障这一点，同时也可以避免出现大量的 getter 方法。而古典主义者们则认为能够达到这个目标的方法其实是多种多样地。

基于状态的验证方法存在这样一个公认问题：它会导致创建一些查询方法而仅仅用于验证。向一个对象的 API 中添加一些纯粹用于测试的方法，这从来都不会让人感到舒服，使用行为验证就可以避免这个问题。而反方观念认为，在实践中这种情况其实并不普遍。

模拟主义者们赞同角色接口，并断言使用模拟主义式测试可以激励（创建出）更多的角色接口，因为每个被单独模拟的 **协作者** 都可以很容易地转化为一个角色接口。一个模拟主义者能够更容易地创造出领域内的特定角色，我上文的案例就使用了一个字符串缓冲来生成报告，而这个字符串缓冲就是一个角色。

我们应该牢记设计风格中的差异会成为绝大多数模拟主义者们最重要的激励要素。TDD 的起源就是因为希望可以通过强力有的自动化回归测试来保障设计的进化。它的实践者们也发现先写测试确实能够明显地改进设计过程。模拟主义者们对什么样的设计才是好的设计这个问题能够有很深入的理解，也因此开发出了诸多模拟库来帮助人们以这种设计风格进行开发。

## <a name="so-should-i-be-classicist-or-mockist"></a> 做古典主义者还是模拟主义者？ ##

我发现这是一个很难脱口而出就回答的问题。就我个人而言，我一直都是一名老派古典的 TDD 实践者，而且时至今日也找不到需要自我改变的理由。我找不到模拟主义式 TDD 中有什么让我无法抗拒的诱惑，也对结合测试来实现（功能）这一方法的价值心存疑问。

这让我在观察模拟主义程序员的工作时觉得不可思议。我真心喜欢在写测试（用例）时就只聚焦在行为的结果上，而非它是怎么完成地。一名模拟主义者需要不停地思考 **SUT** 该如何实现以编写 *期望* 。这会让我感到非常地不自然。

我也在各种项目中遭遇到了不使用模拟主义式 TDD 而引发的问题。但正如我从 TDD 中所学到地，在深入使用一门技术之前，你很难判断它真地对你有益还是无益。我也认识很多优秀的、坚定的、同时还乐在其中的模拟主义式开发者。所以尽管我个人依旧是一名坚定的古典主义者，但我还是希望能够尽量公平地展现两种风格（的优劣），以便于你做出自己的决定。

因此，如果模拟主义式测试很吸引你，那么我建议去试试再说。特别是在你碰到一些问题但又恰好是模拟主义式 TDD 所擅长解决地，那就非常值得一试了。我所了解的有这么两大块。其一是因为测试（用例）粒度问题，导致你无法根据结果快速判断根源所在，而不能不花费大量的时间用于调试的情况。（当然，你也需要优化你的古典主义式 TDD （测试用例）的粒度问题。）其二是你的对象（像一个结构体一样）单薄而缺乏行为（定义），模拟主义式的测试（用例）会帮助你创建更封面的对象。

## <a name="final-thoughts"></a> 最后的想法 ##

出于对单元测试的兴趣， xUnit 框架和 TDD （理念）都得到了发展，越来越多的人们开始使用模拟对象。但很多时候人们的学习和理解都停留在最表面的模拟对象框架，而对模拟主义和古典主义一知半解。不管你倾向于哪种风格，我想了解更直观地了解其间的差异总会是有价值地。即使你并非一名模拟主义者也无需亲手去找一个适合自己的模拟框架，也有必要理解（模拟主义式 TDD 能够）引导软件设计中的许多决策的这种思想。

本文的目的在于指出这些区别，并展示应该如何在两者之间权衡。模拟主义（式 TDD）中的思想要比我学习到地多得多，特别是其在设计风格方面的价值。我希望在接下来的几年中，我们能够看到关于这个主题的更多的文章，以加深我们对于先写测试（用例）后再（业务）代码这一方法的迷人魅力的学习和理解。
